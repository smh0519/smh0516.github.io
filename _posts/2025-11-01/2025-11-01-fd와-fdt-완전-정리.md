---
title: "FD와 FDT 완전 정리"
layout: post
date: 2025-11-01 00:12:53 +0900
categories: ["web", "fd", "FDT", "소캣"]
tags: ["web", "fd", "FDT", "소캣"]
author: "프론트 꿈나무"
original_url: "https://developer-smh.tistory.com/46"
---

---

### 왜 FD와 FDT를 알아야 할까?

---

> 우리가 사용하는 하나의 프로그램(프로세스)은 얼마나 많은 데이터를 다룰까요?  
아마 우리가 상상하는 것 이상으로, 수많은 파일, 네트워크 연결, 장치와 같은 자원들을 동시에 관리하고 있을 거예요.  
  
하지만 컴퓨터도 무한한 데이터를 무질서하게 다룰 수는 없습니다.  
모든 자원을 체계적으로 관리하기 위한 도구가 필요하죠.  
  
바로 그 역할을 하는 것이 FD(File Descriptor) 와 FDT(File Descriptor Table) 입니다.  
이번 글에서는 운영체제가 어떻게 이 두 개념을 통해  
“모든 것을 파일처럼” 다루는지를 쉽게 풀어보겠습니다.  
  
  
  

 

---

### 파일 디스크립터(FD)란 무엇인가?

---

정의

> 파일 디스크립터(File Descriptor, FD)는  
운영체제가 프로세스에게 파일이나 입출력 자원을 식별시키기 위해 부여하는 정수 번호입니다.

 

 

FD가 왜 필요한가

> 운영체제는 수많은 파일과 네트워크 연결을 동시에 관리해야 합니다.  
이를 효율적으로 구분하기 위해, 커널은 각 자원에 번호(FD) 를 붙여 관리합니다.  
그래서 프로그램은 파일 이름이나 소켓 주소 대신 FD 번호로 자원을 구분하고 접근합니다

 

 

표준 FD(기본 3개)

<table style="border-collapse: collapse; width: 100%;" border="1" data-ke-align="alignLeft" data-ke-style="style12">
<tbody>
<tr>
<td style="width: 33.3333%;">FD 번호</td>
<td style="width: 33.3333%;">이름</td>
<td style="width: 33.3333%;">설명</td>
</tr>
<tr>
<td style="width: 33.3333%;">0</td>
<td style="width: 33.3333%;">stdin</td>
<td style="width: 33.3333%;">표준 입력  (키보드)</td>
</tr>
<tr>
<td style="width: 33.3333%;">1</td>
<td style="width: 33.3333%;">stdout</td>
<td style="width: 33.3333%;">표준 출력 (터미널)</td>
</tr>
<tr>
<td style="width: 33.3333%;">2</td>
<td style="width: 33.3333%;">stderr</td>
<td style="width: 33.3333%;">표쥰 에러 출력</td>
</tr>
</tbody>
</table>
 

즉, 프로그램이 시작될 때 이미 0~2번 FD는 자동으로 커널에 의해 열려 있는 상태예요.  
그래서 printf()는 내부적으로 FD 1(stdout)을 사용합니다.

 

 

---

### 파일 디스크립터 테이블(FDT)이란 무엇인가?

---

 

정의

> 파일 디스크립터 테이블(FDT)은 프로세스가 가지고 있는 모든   
파일 디스크립터(FD)를 저장하고 관리하는커널 내부의 테이블(자료구조) 입니다.

 

 

FDF의 구조 

FDT는 단순한 배열 형태의 자료구조로 되어 있습니다.

![image](/assets/img/2025-11-01/img.png)

       이처럼 FDT는 FD 번호 ↔ 파일 구조체 포인터 의 매핑 관계를 관리합니다.

 

 

추상화된 흐름 — “프로그램이 FD를 받기까지"

 

운영체제는 프로그램이 파일이나 소켓에 접근하려고 하면,  
그 자원을 직접 넘겨주는 대신 “번호표(FD)” 를 하나 발급합니다.  
이 번호표가 FDT 안에 등록되죠.

즉, 프로그램이 I/O 자원에 접근하는 과정은 아래처럼 정리할 수 있습니다 .

 

> 
프로그램 요청 → 커널 개입 → FDT에 등록 → FD 반환

 

 

 

---

### FD와 FDT의 관계 (커널 구조 관점)

---

 

 

 

 

구조요약

###  

> 
FD는 단순한 번호표(정수)이고,  
FDT는 그 번호표가 어떤 자원을 가리키는지 기록해둔 “목록표”입니다.

커널은 FDT를 통해 FD 번호를 실제 파일 객체(struct file)로 연결하고,  
이를 통해 파일 시스템, 네트워크, 장치 등을 제어합니다.

 

 

 

### 실제 접근 과정 (예시 흐름)

- 프로세스가 open("data.txt") 호출  
→ 커널이 File Table에 새로운 struct file 객체 생성  
→ 해당 포인터를 프로세스의 FDT[3]에 등록  
→ FD=3 반환

- 프로세스가 read(3, buf, 100) 호출  
→ 커널은 FDT에서 인덱스 3을 찾아 struct file*을 얻음  
→ 그 구조체를 통해 파일의 inode와 데이터에 접근  
→ 읽은 결과를 유저 공간으로 전달

- close(3) 호출  
→ FDT에서 [3] 엔트리 제거  
→ File Table의 참조 카운트 감소  
→ 더 이상 참조하는 프로세스가 없으면 커널이 파일을 닫음

 

```bash
┌─────────────────────────────┐
│         User Process        │
│  fd = open("data.txt") → 3  │
└──────────────┬──────────────┘
               │
               ▼
┌─────────────────────────────┐
│   File Descriptor Table     │  ← 프로세스별
│  [0] → stdin                │
│  [1] → stdout               │
│  [2] → stderr               │
│  [3] → struct file *        │
└──────────────┬──────────────┘
               │
               ▼
┌─────────────────────────────┐
│   Global File Table         │  ← 커널 전체
│  struct file { offset, mode, inode* }  │
└──────────────┬──────────────┘
               │
               ▼
┌─────────────────────────────┐
│       Inode / Socket        │
│     (실제 파일 or 자원)     │
└─────────────────────────────┘
```
 

 

 

---

### 소켓과 FD의 관계

---

 

소켓도 결국 파일이다

운영체제(특히 UNIX/Linux)는 모든 것을 파일처럼 다루는 “Everything is a file” 철학을 가지고 있습니다.  
즉, 파일이든, 파이프든, 소켓이든 — 모두 FD로 표현됩니다.

 

> 그래서 소켓(Socket)도 단순히 네트워크 통신용 파일일 뿐,  
커널 입장에서는 “특수한 종류의 파일 디스크립터”입니다.

 

 

socket() 함수가 호출되면 커널은 소켓 객체를 생성하고, 그 주소를 FDT에 등록하고,  
프로세스에 FD 번호를 반환합니다.

> 
소켓은 FD로 표현된 네트워크 엔드포인트입니다.  
프로그램은 그 FD를 이용해 데이터를 송수신합니다.

 

 

 

 

 

---

> 
“FD는 커널과 프로세스가 소통하는 언어이고,  
FDT는 그 언어의 사전을 정리한 구조다.”
